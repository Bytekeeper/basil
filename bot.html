---
layout: page
permalink: /bot.html
---
<script id="headerTemplate" type="text/x-handlebars-template">
	{% raw %}
	<h1 {{#if race}}class="{{racecol race}}{{/if}}">{{botName}}</h1>
	<hr>
	{{#if won}}
	<div class="row">
	<div class="col-6 row">
	<div class="col-1">
	<i class="fas fa-trophy"></i>
	{{won}}
	</div>
	<div class="col-1">
	<i class="fas fa-sad-tear"></i>
	{{lost}}
	</div>
	<div class="col-1">
	<i class="fas fa-car-crash"></i>
	{{crashed}}
	</div>
	<div class="col-1">
	ELO: {{rating}}
	</div>
	<div class="col-2">
	max-ELO: {{maxElo}}
	</div>
	</div>
	</div>
	<div class="row">
	<div class="col-1">
	Last updated:
	</div>
	<div class="col-5">
	{{date lastUpdated}}
	</div>
	</div>
	{{#unless enabled}}
	<div class="row">
	<div class="col-1">
	Disabled:
	</div>
	<div class="col-3">
	{{disabledReason}}
	</div>
	</div>
	{{/unless}}
	</div>
	{{/if}}
	{% endraw %}
</script>
<script>
	$(function() {
		let statsBaseUrl = "http://basilicum.bytekeeper.org/stats/";
		let botName = decodeURIComponent(window.location.search.substring(1).split("=")[1]);
		let source = $("#headerTemplate").html();
		let template = Handlebars.compile(source);
		let myData;
		let percentFormat = new Intl.NumberFormat(undefined, { style: "percent", minimumFractionDigits: 2}).format
		$("#botName").append(template({botName: botName}));
		let now = Date.now() / 1000;
		let selectedRange = { startSecond:  now - 30 * 86400, endSecond: now };
		let updaters = [];
		$("#startDate").flatpickr({
			defaultDate: new Date(selectedRange.startSecond * 1000),
			onChange: function(selectedDates) {
				selectedRange.startSecond = selectedDates[0].getTime() / 1000;
				updaters.forEach(function(x) {x.apply();});
			}
		});
		$("#endDate").flatpickr({
			defaultDate: new Date(selectedRange.endSecond * 1000),
			onChange: function(selectedDates) {
				selectedRange.endSecond = selectedDates[0].getTime() / 1000 + 86400;
				updaters.forEach(function(x) {x.apply();});
			}

		});
		$.getJSON(statsBaseUrl + "ranking.json")
			.then(function(data) {
				data = data.filter(function(b) { return b.enabled; })
					.sort(function(a,b) { 
						if (a.rating !== b.rating) return b.rating - a.rating; 
						if (a.winRate !== b.winRate) return b.winRate - a.winRate;
						return b.won - a.won;
					});
				let topBots = data.slice(0,5).map(function(bot) { return bot.botName; });
				let myIndex = topBots.indexOf(botName);
				if (myIndex === -1) topBots.push(botName); 
				else {
					let tmp = topBots[topBots.length - 1];
					topBots[topBots.length - 1] = topBots[myIndex];
					topBots[myIndex] = tmp;
				}
				$("#botName").empty();
				myData = data.filter(function(a) { return a.botName === botName; })[0];
				myData.maxElo = "-";
				if (!myData.enabled) myData.disabledReason = myData.disabledReason || "Disabled on SSCAIT/locally";
				$("#botName").append(template(myData));
				return $.when.apply($, topBots.map(function(bot) {
					return $.getJSON(statsBaseUrl + bot + "/eloHistory.json")
						.then(function(data) { return {name: bot, data: data}; });
				}));
			}).then(function() {
				const colors = [
					"rgba(200, 0, 0, 0.8)",
					"rgba(0, 200, 0, 0.4)",
					"rgba(200, 200, 0, 0.4)",
					"rgba(0, 0, 200, 0.4)",
					"rgba(200, 0, 200, 0.4)",
					"rgba(200, 200, 200, 0.4)",
				];
				let args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)).reverse();
				let maxElo = 0;
				let myElos = args[0].data;
				for (i = 0; i < myElos.length; i++) {
					maxElo = Math.max(maxElo, myElos[i].rating);
				}

				$("#botName").empty();
				myData.maxElo = maxElo;
				$("#botName").append(template(myData));

				function prepareDataSets() {
					let startSecond = selectedRange.startSecond;
					let endSecond = selectedRange.endSecond;
					if (typeof startSecond === "undefined" || typeof endSecond === "undefined" || startSecond >= endSecond)
						return {label: unescape(bot.name), fill: false, data: []};
					let secondsToAggregate = (endSecond - startSecond) / 60;
					return args.map(function(bot, i) {
						function filter(data) {
							data.sort(function(a,b) { return a.epochSecond - b.epochSecond; });
							let chartData = [];
							let lastSecond = 0;
							for (i = 0; i < data.length && lastSecond < endSecond; i++) {
								let entry = data[i];
								if (entry.epochSecond >= startSecond && entry.epochSecond <= endSecond && entry.epochSecond - lastSecond >= secondsToAggregate) {
									chartData.push({x: new Date(entry.epochSecond * 1000), y: entry.rating});
									lastSecond = entry.epochSecond;
								}
							}
							return chartData;
						}
						return {
							label: unescape(bot.name),
							fill: false,
							borderColor: colors[i],
							data: filter(bot.data)

						};
					});
				}

				let datasets = prepareDataSets();
				let ctx = document.getElementById("eloChart");
				let eloChart = new Chart(ctx, {
					type: "line",
					data: {
						datasets: datasets
					},
					options: {
						scales: {
							xAxes: [{
								type: "time",
								time: {
									unit: "day"
								}
							}]
						}
					}
				});
				updaters.push(function() {
					eloChart.data.datasets = prepareDataSets();
					eloChart.update();
				});
			});
		function setupPerMapWinsChart(data) {
			let labels = data.maps.sort();
			function prepareDataSets() {
				let map = data.maps.map(function(x) {
					return {won: 0, lost: 0, map: x};
				});
				data.results.forEach(function(x) {
					let epochSecond = parseInt(x.t, 16) * 3600;
					if (epochSecond >= selectedRange.startSecond && epochSecond <= selectedRange.endSecond) {
						let stat = map[x.m];
						if (x.w === 1) stat.won++; else stat.lost++;
					}
				}, {});
				map.sort(function(a,b) {
					if (a.map > b.map) return 1;
					if (a.map < b.map) return -1;
					return 0;
				});
				let wonData = map.map(function(a) { return a.won; });
				let lostData = map.map(function(a) { return a.lost; });
				return [{
					label: "Won",
					data: wonData,
					backgroundColor: "#88AAEB"
				}, {
					label: "Lost",
					data: lostData,
					backgroundColor: "#EBAAAA"
				}];
			}
			let datasets = prepareDataSets();
			let winCharts = new Chart(document.getElementById("perMapWinsChart"), {
				type: "bar",
				data: {
					datasets: datasets
				},
				options: {
					scales: {
						xAxes: [{
							stacked: true,
							type: "category",
							labels: labels,
							ticks: {
								autoSkip: false
							}
						}],
						yAxes: [{
							stacked: true
						}]
					},
					tooltips: {
						mode: "index",
						callbacks: {
							footer: function(tooltipItems, data) {
								let wins = tooltipItems[0].yLabel;
								let losses = tooltipItems[1].yLabel;
								let wr = wins / Math.max(1, wins + losses);
								return "WR: " + percentFormat(wr);
							}
						}
					}
				}
			});
			updaters.push(function() {
				winCharts.data.datasets = prepareDataSets();
				winCharts.update();
			});

		}
      		function setupVsChart(data) {
			let vsChart = new Chart(document.getElementById("vsChart"), {
				type: "bar",
				options: {
					tooltips: {
						mode: "index",
						callbacks: {
							footer: function(tooltipItems, data) {
								let wins = tooltipItems[0].yLabel;
								let losses = tooltipItems[1].yLabel;
								let wr = wins / Math.max(1, wins + losses);
								return "WR: " + percentFormat(wr);
							}
						}
					}
				}
			});
      			function updateChart() {
				let bots = data.bots.map(function(x) {
					return {won: 0, lost: 0, bot: x};
				});
				data.results.forEach(function(x) {
					let epochSecond = parseInt(x.t, 16) * 3600;
					if (epochSecond >= selectedRange.startSecond && epochSecond <= selectedRange.endSecond) {
						let stat = bots[x.e - 1];
						if (x.w === 1) stat.won++; else stat.lost++;
					}
				}, {});
      				bots = bots.filter(function(x) { return x.won + x.lost > 0; });
				bots.sort(function(a,b) {
					let dWR = a.won / (a.won + a.lost) - b.won / (b.won + b.lost);
					if (dWR != 0) return dWR;
					if (a.lost > b.lost) return -1;
					if (a.lost < b.lost) return 1;
					return 0;
				}).slice(0, 30);
				let wonData = bots.map(function(a) { return a.won; });
				let lostData = bots.map(function(a) { return a.lost; });
			        let labels = bots.map(function(x) { return x.bot; });
				vsChart.data.datasets = [{
					label: "Won",
					data: wonData,
					backgroundColor: "#88AAEB"
				}, {
					label: "Lost",
					data: lostData,
					backgroundColor: "#EBAAAA"
				}];
      				vsChart.options.scales = {
					xAxes: [{
						stacked: true,
						type: "category",
						labels: labels,
						ticks: {
							autoSkip: false
						}
					}],
					yAxes: [{
						stacked: true
					}]
				};
				vsChart.update();
       			}
      			updateChart();
			updaters.push(updateChart);
		}
		function setupMatchupChart(data) {
			let chart = new Chart(document.getElementById("perRaceWinsChart"), {
				type: "bar",
				options: {
					tooltips: {
						mode: "index",
						callbacks: {
							footer: function(tooltipItems, data) {
								let wins = tooltipItems[0].yLabel;
								let losses = tooltipItems[1].yLabel;
								let wr = wins / Math.max(1, wins + losses);
								return "WR: " + percentFormat(wr);
							}
						}
					}
				}
			});
      			function updateChart() {
			        let rvr = {};
      				let races = ["T", "P", "Z", "R"];
			        let raceLabel = { "T": "Terran", "P": "Protoss", "R": "Unknown", "Z": "Zerg" };
      				races.forEach(function(a) {
					races.forEach(function(b) {
						rvr[a + b] = {label: raceLabel[a] + " vs " + raceLabel[b], won: 0, lost: 0};
					});
				});
				data.results.forEach(function(x) {
					let epochSecond = parseInt(x.t, 16) * 3600;
					if (epochSecond >= selectedRange.startSecond && epochSecond <= selectedRange.endSecond) {
						let stat = rvr[x.r + x.er];
						if (x.w === 1) stat.won++; else stat.lost++;
					}
				}, {});
      				let rvrList = [];
      				races.forEach(function(a) {
					races.forEach(function(b) {
					        rvrList.push(rvr[a + b]);
					});
			        });
      				rvrList = rvrList.filter(function(x) { return x.won + x.lost > 0; });
				rvrList.sort(function(a,b) {
					let dWR = a.won / (a.won + a.lost) - b.won / (b.won + b.lost);
					if (dWR != 0) return dWR;
					if (a.lost > b.lost) return -1;
					if (a.lost < b.lost) return 1;
					return 0;
				});
				let wonData = rvrList.map(function(a) { return a.won; });
				let lostData = rvrList.map(function(a) { return a.lost; });
			        let labels = rvrList.map(function(x) { return x.label; });
				chart.data.datasets = [{
					label: "Won",
					data: wonData,
					backgroundColor: "#88AAEB"
				}, {
					label: "Lost",
					data: lostData,
					backgroundColor: "#EBAAAA"
				}];
      				chart.options.scales = {
					xAxes: [{
						stacked: true,
						type: "category",
						labels: labels,
						ticks: {
							autoSkip: false
						}
					}],
					yAxes: [{
						stacked: true
					}]
				};
				chart.update();
       			}
      			updateChart();
			updaters.push(updateChart);
	        }
		$.get(statsBaseUrl + botName + "/allGameResults.json", undefined, undefined, "text")
			.then(function(_data) {
				let data = eval('(' + _data + ')');
				setupPerMapWinsChart(data);
				setupVsChart(data);
				setupMatchupChart(data);
			});
	});
</script>
<div id="botName"></div>
<h2>ELO</h2>
<form>
<div class="row">
	<div class="col-1">
	<label for="startDate">Start</label>
	<input style="width: 6em; text-align: right;" id="startDate" type="text" readonly="readonly">
	</div>
	<div class="col-1">
	<label for="endDate">End</label>
	<input style="width: 6em; text-align: right;" id="endDate" type="text" readonly="readonly">
	</div>
</div>
</form>
<canvas id="eloChart" width="1200" height="600">
</canvas>
<h2>Wins Per Map</h2>
<canvas id="perMapWinsChart" width="1200" height="300">
</canvas>
<h2>Vs</h2>
<p>Top 30 contenders, sorted by WR, ties broken by #losses:</p>
<canvas id="vsChart" width="1200" height="300">
</canvas>
<h2>Wins Per Race</h2>
<small>Please note that unknown means it was random but the actual preselected race was not recorded.</small>
<canvas id="perRaceWinsChart" width="1200" height="300">
</canvas>
</table>
