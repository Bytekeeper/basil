---
layout: page
permalink: /bot.html
---
{% raw %}
<div id="botName"
	style="height: 2em; position: sticky; top: 0px; margin-bottom: 10px; border-bottom: 2px solid black; z-index: 999;">
</div>
<div id="botData"></div>
<h2>Games in the last 24h</h2>
<table id="gamesTable">
	<thead>
		<tr style="position: sticky; top: 2em; z-index: 900;">
			<th>Bot A</th>
			<th>Bot B</th>
			<th class="filter-select">Map</th>
			<th class="filter-false">Ended At</th>
			<th class="filter-false" data-sorter="false">Game time</th>
			<th class="filter-false" data-sorter="false"><i class="fas fa-download"></i></th>
			<th class="filter-false" data-sorter="false"><i class="fas fa-eye"></i></th>
		</tr>
	</thead>
	<tbody>
	</tbody>
</table>
<form style="padding-top: 0.5em; position: sticky; top: 2em; background-color:white">
	<div class="row">
		<div class="col-1">
			<label for="startDate">Start</label>
			<input style="width: 6em; text-align: right;" id="startDate" type="text" readonly="readonly">
		</div>
		<div class="col-1">
			<label for="endDate">End</label>
			<input style="width: 6em; text-align: right;" id="endDate" type="text" readonly="readonly">
		</div>
	</div>
	<hr style="margin-top: 10px;">
</form>
<h2>ELO</h2>
<canvas id="eloChart" width="1200" height="600">
</canvas>
<h2>Wins Per Map</h2>
<canvas id="perMapWinsChart" width="1200" height="300">
</canvas>
<h2>Vs</h2>
<small>Top 70 contenders, sorted by WR, ties broken by #losses:</small>
<canvas id="vsChart" width="1200" height="300">
</canvas>
<h2>Wins Per Race</h2>
<small>Please note that unknown means it was random but the actual preselected race was not recorded.</small><br>
<small>Graph W/L is displayed, as if the bot started playing at the beginning of the selected time range.</small>
<canvas id="perRaceWinsChart" width="1200" height="600">
</canvas>
<h2>Close Opposition</h2>
<small>Top 10 bots with similar strength.</small><br>
<canvas id="vs2Chart" width="1200" height="600"></canvas>
</table>
<script>
	function nameTemplate(bot) {
		return html`
			<h1 style="height: 1.5em;" $${bot.race ?
				html`class="${basil.racecol(bot.race)}"` : ""}>${bot.botName} 
				<div style="position: relative;" class="tooltip medal ${bot.medal}">${bot.rank}<span role="tooltip">Current Rank</span></div>
				<span class="float-right">${basil.racename && bot.race ? basil.racename(bot.race) : "-"}</span ></h1>`;
	}
	function headerTemplate(bot) {
		return html`
				$${bot.won ? html`
					<div class="row">
					<div class="col-6 row">
					<div class="col-1">
					<i class="fas fa-trophy tooltip space-right"><span role="tooltip">Wins</span></i>
					${bot.won}
					</div>
					<div class="col-1">
					<i class="fas fa-sad-tear tooltip space-right"><span role="tooltip">Losses</span></i>
					${bot.lost}
					</div>
					<div class="col-1">
					<i class="fas fa-car-crash tooltip space-right"><span role="tooltip">Crashes</span></i>
					${bot.crashed}
					</div>
					</div>
					</div>
					<div class="row">
					<div class="col-1">
					Last updated:
					</div>
					<div class="col-1">
					${basil.formatDate(bot.lastUpdated)}
					</div>
					</div>
					<div class="row">
					<div class="col-1">
					ELO
					</div>
					<div class="col-1">
					${bot.basilRating || bot.rating}
					</div>
					</div>
					<div class="row">
					<div class="col-1">
					max-ELO
					</div>
					<div class="col-1">
					${bot.maxElo}
					</div>
					</div>
					</div>

				${!bot.enabled ? html`
						<div class="row">
						<div class="col-1">
						Disabled:
						</div>
						<div class="col-3">
						${bot.disabledReason}
						</div>
						</div>

					` : ""}
				` : ""}
				`;
	}
	$(function () {
		const CSS_COLOR_NAMES = ["Black", "Blue", "BlueViolet", "Brown", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "Coral", "CornflowerBlue", "Crimson", "Cyan", "DarkBlue", "DarkCyan", "DarkGoldenRod", "DarkGray", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "DarkOrange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGrey", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGrey", "DodgerBlue", "FireBrick", "ForestGreen", "Fuchsia", "Gainsboro", "Gold", "GoldenRod", "Grey", "Green", "GreenYellow", "HotPink", "IndianRed", "Indigo", "Ivory", "Khaki", "Lavender", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenRodYellow", "LightGreen", "LightPink", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSlateGrey", "LightSteelBlue", "Lime", "LimeGreen", "Linen", "Magenta", "Maroon", "MediumAquaMarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MistyRose", "Moccasin", "Navy", "Olive", "OliveDrab", "Orange", "OrangeRed", "Orchid", "PaleGoldenRod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PeachPuff", "Peru", "Pink", "Plum", "PowderBlue", "Purple", "RebeccaPurple", "Red", "RosyBrown", "RoyalBlue", "SaddleBrown", "Salmon", "SandyBrown", "SeaGreen", "Sienna", "Silver", "SkyBlue", "SlateBlue", "SlateGray", "SlateGrey", "SpringGreen", "SteelBlue", "Tan", "Teal", "Thistle", "Tomato", "Turquoise", "Violet", "Wheat", "Yellow", "YellowGreen"];

		let statsBaseUrl = "https://basilicum.bytekeeper.org/stats/";
		let botName = decodeURIComponent(window.location.search.substring(1).split("=")[1]);
		let myData;
		$("#botName").append(nameTemplate({ botName: botName }))
		$("#botData").append(headerTemplate({ botName: botName }));
		let now = Date.now() / 1000;
		let selectedRange = { startSecond: now - 30 * 86400, endSecond: now };
		let secondsToAggregate = (selectedRange.endSecond - selectedRange.startSecond) / 60;
		let updaters = [];
		$("#startDate").flatpickr({
			defaultDate: new Date(selectedRange.startSecond * 1000),
			onChange: function (selectedDates) {
				selectedRange.startSecond = selectedDates[0].getTime() / 1000;
				secondsToAggregate = (selectedRange.endSecond - selectedRange.startSecond) / 60;
				updaters.forEach(function (x) { x.apply(); });
			}
		});
		$("#endDate").flatpickr({
			defaultDate: new Date(selectedRange.endSecond * 1000),
			onChange: function (selectedDates) {
				selectedRange.endSecond = selectedDates[0].getTime() / 1000 + 86400;
				secondsToAggregate = (selectedRange.endSecond - selectedRange.startSecond) / 60;
				updaters.forEach(function (x) { x.apply(); });
			}

		});
		$.getJSON(statsBaseUrl + "ranking.json")
			.then(function (data) {
				basil.sortByRank(data);
				let topBots = data.slice(0, 5).map(function (bot) { return bot.botName; });
				let myIndex = topBots.indexOf(botName);
				if (myIndex === -1) topBots.push(botName);
				else {
					let tmp = topBots[topBots.length - 1];
					topBots[topBots.length - 1] = topBots[myIndex];
					topBots[myIndex] = tmp;
				}
				$("#botName").empty();
				$("#botData").empty();
				myData = data.filter(function (a) { return a.botName === botName; })[0];
				myData.maxElo = "-";
				myData.rank = data.indexOf(myData) + 1;
				if (myData.rank == 1) myData.medal = "gold";
				else if (myData.rank == 2) myData.medal = "silver";
				else if (myData.rank == 3) myData.medal = "bronze";
				else if (myData.rank < 100) myData.medal = "gray";
				else myData.medal = "";
				if (!myData.enabled) myData.disabledReason = myData.disabledReason || "Disabled on SSCAIT/locally";
				$("#botName").append(nameTemplate(myData))
				$("#botData").append(headerTemplate(myData));
				return $.when.apply($, topBots.map(function (bot) {
					return $.getJSON(statsBaseUrl + bot + "/eloHistory.json")
						.then(function (data) { return { name: bot, data: data }; });
				}));
			}).then(function () {
				const colors = [
					"rgba(200, 0, 0, 0.8)",
					"rgba(0, 200, 0, 0.4)",
					"rgba(200, 200, 0, 0.4)",
					"rgba(0, 0, 200, 0.4)",
					"rgba(200, 0, 200, 0.4)",
					"rgba(200, 200, 200, 0.4)",
				];
				let args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)).reverse();
				let maxElo = 0;
				let myElos = args[0].data;
				for (i = 0; i < myElos.length; i++) {
					maxElo = Math.max(maxElo, myElos[i].rating);
				}

				$("#botName").empty();
				$("#botData").empty();
				myData.maxElo = maxElo;
				$("#botName").append(nameTemplate(myData));
				$("#botData").append(headerTemplate(myData));

				function prepareDataSets() {
					let startSecond = selectedRange.startSecond;
					let endSecond = selectedRange.endSecond;
					if (typeof startSecond === "undefined" || typeof endSecond === "undefined" || startSecond >= endSecond)
						return { label: unescape(bot.name), fill: false, data: [] };
					return args.map(function (bot, index) {
						function filter(data) {
							data.sort(function (a, b) { return a.epochSecond - b.epochSecond; });
							let chartData = [];
							let lastSecond = 0;
							let updated = false;
							for (i = 0; i < data.length && lastSecond < endSecond; i++) {
								let entry = data[i];
								if (entry.epochSecond >= startSecond && entry.epochSecond <= endSecond) {
									updated |= entry.updated || false;
									if (entry.epochSecond - lastSecond >= secondsToAggregate) {
										chartData.push({ x: new Date(entry.epochSecond * 1000), y: entry.rating, updated: updated });
										updated = false;
										lastSecond = entry.epochSecond;
									}
								}
							}
							return chartData;
						}
						let data = filter(bot.data);
						return {
							label: unescape(bot.name),
							fill: false,
							borderColor: colors[index],
							data: data,
							cubicInterpolationMode: "monotone",
							pointBackgroundColor: data.map(e => e.updated ? colors[index] : 'transparent'),
							pointRadius: data.map(e => e.updated ? 5 : 3)
						};
					});
				}

				let datasets = prepareDataSets();
				let ctx = document.getElementById("eloChart");
				let eloChart = new Chart(ctx, {
					type: "line",
					data: {
						datasets: datasets
					},
					options: {
						scales: {
							xAxes: [{
								type: "time",
								time: {
									unit: "day"
								}
							}]
						},
						tooltips: {
							mode: "nearest",
							callbacks: {
								footer: function (tooltipItems, data) {
									const item = tooltipItems[0];
									const updated = data.datasets[item.datasetIndex].data[item.index].updated;
									let elo = item.yLabel;
									return updated ? "Updated version" : null;
								}
							}

						}
					}
				});
				updaters.push(function () {
					eloChart.data.datasets = prepareDataSets();
					eloChart.update();
				});
			});
		function setupPerMapWinsChart(data) {
			let winCharts = new Chart(document.getElementById("perMapWinsChart"), {
				type: "bar",
				plugins: [ChartDataLabels],
				options: {
					plugins: {
						datalabels: {
							align: "top",
							formatter: function (value, context) {
								let wins = context.chart.data.datasets[0].data[context.dataIndex];
								let losses = context.chart.data.datasets[1].data[context.dataIndex];
								let wr = wins / Math.max(1, wins + losses);
								return basil.percentFormat(wr, 1);
							}
						}
					},
					tooltips: {
						mode: "index",
						callbacks: {
							footer: function (tooltipItems, data) {
								let wins = tooltipItems[0].yLabel;
								let losses = tooltipItems[1].yLabel;
								let wr = wins / Math.max(1, wins + losses);
								return "WR: " + basil.percentFormat(wr);
							}
						}
					}
				}
			});
			function updateChart() {
				let map = data.maps.map(function (x) {
					return { won: 0, lost: 0, map: x };
				});
				data.results.forEach(function (x) {
					let epochSecond = x.t;
					if (epochSecond >= selectedRange.startSecond && epochSecond <= selectedRange.endSecond) {
						let stat = map[x.m];
						if (x.w === 1) stat.won++; else stat.lost++;
					}
				}, {});
				map = map.filter(function (x) { return x.lost + x.won > 0; })
					.sort(function (a, b) {
						let dWR = a.won / Math.max(1, a.won + a.lost) - b.won / Math.max(1, b.won + b.lost);
						if (dWR != 0) return dWR;
						if (a.lost > b.lost) return -1;
						if (a.lost < b.lost) return 1;
						return 0;
					});
				let wonData = map.map(function (a) { return a.won; });
				let lostData = map.map(function (a) { return a.lost; });
				let labels = map.map(function (a) { return a.map; });
				winCharts.data.datasets = [{
					label: "Won",
					data: wonData,
					backgroundColor: "#88AAEB",
				}, {
					label: "Lost",
					data: lostData,
					backgroundColor: "#EBAAAA",
					datalabels: {
						display: false
					}
				}];
				winCharts.options.scales = {
					xAxes: [{
						stacked: true,
						type: "category",
						labels: labels,
						ticks: {
							autoSkip: false
						}
					}],
					yAxes: [{
						stacked: true
					}]
				};

				winCharts.update();
			}
			updateChart();
			updaters.push(updateChart);
		}
		function setupVsChart(data) {
			let vsChart = new Chart(document.getElementById("vsChart"), {
				type: "bar",
				plugins: [ChartDataLabels,
					{
						beforeEvent: function (chartInstance, chartEvent) {
							var xAxis = chartInstance.scales['x-axis-0'];

							// If mouse is over the legend, change cursor style to pointer, else don't show it
							var x = chartEvent.x;
							var y = chartEvent.y;

							if (chartEvent.type === 'click' &&
								x <= xAxis.right && x >= xAxis.left &&
								y <= xAxis.bottom && y >= xAxis.top) {
								// category scale returns index here for some reason
								var index = xAxis.getValueForPixel(x);
								console.log(chartInstance.data.labels[index]);
							}
						}
					}],
				options: {
					plugins: {
						datalabels: {
							rotation: -85,
							font: {
								size: 10
							},
							align: "top",
							formatter: function (value, context) {
								let wins = context.chart.data.datasets[0].data[context.dataIndex];
								let losses = context.chart.data.datasets[1].data[context.dataIndex];
								let wr = wins / Math.max(1, wins + losses);
								return basil.percentFormat(wr, 1);
							},
						}
					},
					tooltips: {
						mode: "index",
						callbacks: {
							footer: function (tooltipItems, data) {
								let wins = tooltipItems[0].yLabel;
								let losses = tooltipItems[1].yLabel;
								let wr = wins / Math.max(1, wins + losses);
								return "WR: " + basil.percentFormat(wr);
							}
						}
					}
				}
			});
			function updateChart() {
				let bots = data.bots.map(function (x) {
					return { won: 0, lost: 0, bot: x };
				});
				data.results.forEach(function (x) {
					let epochSecond = x.t;
					if (epochSecond >= selectedRange.startSecond && epochSecond <= selectedRange.endSecond) {
						let stat = bots[x.e];
						if (x.w === 1) stat.won++; else stat.lost++;
					}
				}, {});
				bots = bots.filter(function (x) { return x.won + x.lost > 0; });
				bots = bots.sort(function (a, b) {
					let dWR = a.won / (a.won + a.lost) - b.won / (b.won + b.lost);
					if (dWR != 0) return dWR;
					if (a.lost > b.lost) return -1;
					if (a.lost < b.lost) return 1;
					return 0;
				}).slice(0, 70);
				let wonData = bots.map(function (a) { return a.won; });
				let lostData = bots.map(function (a) { return a.lost; });
				let labels = bots.map(function (x) { return x.bot; });
				vsChart.data.datasets = [{
					label: "Won",
					data: wonData,
					backgroundColor: "#88AAEB"
				}, {
					label: "Lost",
					data: lostData,
					backgroundColor: "#EBAAAA",
					datalabels: {
						display: false
					}
				}];
				vsChart.options.scales = {
					xAxes: [{
						stacked: true,
						type: "category",
						labels: labels,
						ticks: {
							autoSkip: false
						}
					}],
					yAxes: [{
						stacked: true
					}]
				};
				vsChart.update();
			}
			updateChart();
			updaters.push(updateChart);
		}
		function aggWinLossFilter(data) {
			let steplen = Math.ceil(data.length / 30);
			let step = 0;
			let result = [];
			let y = 0;
			for (i = 0; i < data.length; i++) {
				let d = data[i];
				y += d.y;
				step++;
				if (step == steplen || i == data.length - 1) {
					result.push({ x: d.x, y: Math.round(100 * y / step) / 100, w: d.w, l: d.l });
					y = 0;
					step = 0;
				}
			}
			return result;
		}
		function setupRaceMatchupChart(data) {
			let chart = new Chart(document.getElementById("perRaceWinsChart"), {
				type: "line",
				options: {
					tooltips: {
						callbacks: {
							footer: function (tooltipItem, data) {
								let e = data.datasets[tooltipItem[0].datasetIndex].data[tooltipItem[0].index];
								return "W-L: " + e.w + " - " + e.l;
							}
						}
					},
					scales: {
						xAxes: [{
							type: "time",
							time: {
								unit: "day"
							}
						}],
						yAxes: [{
							ticks: {
								callback: function (value, index, values) {
									return value + "%";
								}
							}
						}]
					}
				}
			});
			function updateChart() {
				let rvr = {};
				let races = ["T", "P", "Z", "R"];
				let raceLabel = { "T": "Terran", "P": "Protoss", "R": "Unknown", "Z": "Zerg" };
				races.forEach(function (a, i) {
					races.forEach(function (b, j) {
						rvr[a + b] = { label: raceLabel[a] + " vs " + raceLabel[b], won: 0, lost: 0, data: [], a: i, b: j };
					});
				});
				data.results.forEach(function (x) {
					let epochSecond = x.t;
					if (epochSecond >= selectedRange.startSecond && epochSecond <= selectedRange.endSecond) {
						let stat = rvr[x.r + x.eR];
						if (x.w === 1) stat.won++; else stat.lost++;
						if (stat.won + stat.lost > 0) {
							stat.data.push({ x: new Date(epochSecond * 1000), y: 100 * stat.won / (stat.won + stat.lost), w: stat.won, l: stat.lost });
						}
					}
				}, {});
				let rvrList = [];
				races.forEach(function (a) {
					races.forEach(function (b) {
						rvrList.push(rvr[a + b]);
					});
				});

				chart.data.datasets = rvrList
					.filter(r => r.data.length > 0)
					.map((r, i) => {
						return {
							label: r.label,
							data: aggWinLossFilter(r.data),
							fill: false,
							borderColor: CSS_COLOR_NAMES[i],
							cubicInterpolationMode: "monotone",
						}
					});
				chart.update();
			}
			updateChart();
			updaters.push(updateChart);
		}
		function setupBotMatchupChart(data) {
			let chart = new Chart(document.getElementById("vs2Chart"), {
				type: "line",
				options: {
					tooltips: {
						callbacks: {
							footer: function (tooltipItem, data) {
								let e = data.datasets[tooltipItem[0].datasetIndex].data[tooltipItem[0].index];
								return "W-L: " + e.w + " - " + e.l;
							}
						}
					},
					scales: {
						xAxes: [{
							type: "time",
							time: {
								unit: "day"
							}
						}],
						yAxes: [{
							ticks: {
								callback: function (value, index, values) {
									return value + "%";
								}
							}
						}]
					}
				}
			});
			function updateChart() {
				let vs = {};
				data.results.forEach(function (x) {
					let epochSecond = x.t;
					if (epochSecond >= selectedRange.startSecond && epochSecond <= selectedRange.endSecond) {
						let stat = vs[x.e] = (vs[x.e] || { won: 0, lost: 0, data: [], label: data.bots[x.e] });
						if (x.w === 1) stat.won++; else stat.lost++;
						if (stat.won + stat.lost > 0) {
							stat.data.push({ x: new Date(epochSecond * 1000), y: 100 * stat.won / (stat.won + stat.lost), w: stat.won, l: stat.lost, label: stat.label });
						}
					}
				}, {});
				let relevantSet = Object.values(vs)
					.filter(r => r.data.length > 0);
				relevantSet.sort((a, b) => Math.abs(a.won / (a.won + a.lost) - 0.5) - Math.abs(b.won / (b.won + b.lost) - 0.5));
				relevantSet = relevantSet.slice(0, 10);

				chart.data.datasets = relevantSet
					.map((r, i) => {
						return {
							label: r.label,
							data: aggWinLossFilter(r.data),
							fill: false,
							borderColor: CSS_COLOR_NAMES[i],
							cubicInterpolationMode: "monotone",
						}
					});
				chart.update();
			}
			updateChart();
			updaters.push(updateChart);
		}
		$.get(statsBaseUrl + botName + "/allGameResults.json", undefined, undefined, "text")
			.then(function (_data) {
				let data = eval('(' + _data + ')');
				data.results.forEach(d => {
					d.t = parseInt(d.t, 16) * 3600;
					d.e--;
				});
				data.results.sort((a, b) => a.t - b.t);
				setupPerMapWinsChart(data);
				setupVsChart(data);
				setupRaceMatchupChart(data);
				setupBotMatchupChart(data);
			});

		$.get(statsBaseUrl + "games_24h.json", undefined, undefined, "text")
			.then(function (_data) {
				let data = eval('(' + _data + ')');
				let g = data.results;
				let maps = data.maps;
				let bots = data.bots;
				let games = [];
				for (i = 0; i < g.length; i++) {
					let gameTime = undefined;
					if (g[i].fc) {
						let secs = Math.round(g[i].fc / 24);
						if (secs > 59) gameTime = Math.floor(secs / 60) + "m "; else gameTime = "";
						gameTime += Math.ceil(secs % 60) + "s";
					}
					let [botA, botB] = [g[i].a, g[i].b].map(desc => {
						let bot = bots[desc.b];
						return {
							name: bot.name,
							winner: desc.w === 1,
							loser: desc.l === 1,
							crashed: desc.c === 1,
							race: desc.r || bot.race,
							randomBot: desc.r && desc.r !== bot.race
						};
					});
					if (botA.name !== botName && botB.name !== botName) {
						continue;
					}
					let map = maps[g[i].m];
					let events = g[i].ev && g[i].ev.reduce((acc, e) => {
						let m = acc[e.u] = (acc[e.u] || {});
						m[e.e] = e.c;
						return acc;
					}, {}) || {};

					games.push({
						botA: botA,
						botB: botB,
						time: basil.formatDateTime(parseInt(g[i].e, 16) * 60),
						timestamp: parseInt(g[i].e, 16),
						replayUrl: "https://basilicum.bytekeeper.org/bots/" + botA.name + "/" + botA.name + " vs " + botB.name + " " + map + " " + g[i].h + ".rep",
						gameTime: gameTime,
						notPlayed: !g[i].fc,
						validGame: g[i].iv !== 1 && g[i].to != 1,
						realTimeout: g[i].to === 1,
						frameTimeout: g[i].fo === 1,
						map: map,
						nukes: events[14] && events[14][6],
						mm: (events[0] ? events[0][2] : 0) + (events[34] ? events[34][2] : 0),
						cruisercarrier: (events[72] ? events[72][2] : 0) + (events[12] ? events[12][2] : 0),
						arbiter: events[71] && events[71][2],
						lurkers: events[103] && events[103][2],
						queens: events[45] && events[45][2],
						guardians: events[44] && events[44][2],
						defilers: events[46] && events[46][2],
					});
				}
				// Required for index to work as expected
				games.sort(function (a, b) {
					return b.timestamp - a.timestamp;
				});
				function tableTemplate(games) {
					function bot(bot) {
						return html`
				<td class='${basil.racecol(bot.race) + (bot.randomBot ? "_random" : "")}'>
				<a class="normal" href="ranking.html#${bot.name}">$${bot.winner ? html`<i class="fas fa-trophy"></i>` : ""}$${bot.crashed ? html`<i class="fas fa-car-crash"></i>`
								: bot.loser ? html`<i class="fas fa-sad-tear"></i>` : ""} ${bot.name}
				<div class="float-right normal"><i class="fas fa-align-left"></i></div></a>
				</td>
				`;
					}
					return html`
		${games.map(game => html`
			<tr>
			$${bot(game.botA)}
			$${bot(game.botB)}
			<td>${game.map}</td>
			<td class="nowrap">${game.time}</td>
			<td class="overlayed">$${ html`$${game.notPlayed ? html`<i class="fas fa-poo-storm"</i> ` : ""}$${game.realTimeout ? html`<i class="fas fa-fish"></i> ` : ""}$${game.frameTimeout ? html`<i class="fas fa-stopwatch"></i> ` : ""}${game.gameTime}`}<div class="overlay">
			$${ game.nukes > 1 ? html`<i class="tooltip fas fa-radiation"><span role="tooltip">${game.nukes} nukes</span></i>` : ""}
			$${ game.mm >= 400 ? html`<i class="tooltip fas fa-biohazard"><span role="tooltip">${game.mm} M&M</span></i>` : ""}
			$${ game.cruisercarrier >= 20 ? html`<i class="tooltip fas fa-fighter-jet"><span role="tooltip">${game.cruisercarrier} BC + Carrier</span></i>` : ""}
			$${ game.arbiter >= 10 ? html`<i class="tooltip fas fa-user-secret"><span role="tooltip">${game.arbiter} Arbiter</span></i>` : ""}
			$${ game.lurkers >= 100 ? html`<i class="tooltip fas fa-spider"><span role="tooltip">${game.lurkers} Lurkers</span></i>` : ""}
			$${ game.queens >= 80 ? html`<i class="tooltip fas fa-chess-queen"><span role="tooltip">${game.queens} Queens</span></i>` : ""}
			$${ game.guardians >= 10 ? html`<i class="tooltip fas fa-pastafarianism"><span role="tooltip">${game.guardians} Guardians</span></i>` : ""}
			$${ game.defilers >= 10 ? html`<i class="tooltip fas fa-smog"><span role="tooltip">${game.defilers} Defilers</span></i>` : ""}
			</div></td>
			<td>$${game.validGame ? html`<a href="${game.replayUrl}"><i class="fas fa-download"></i></a>` : ""}</td>
			<td>$${game.validGame ? html`<a href="http://www.openbw.com/replay-viewer/?rep=${game.replayUrl}" target="_blank">OpenBW</a>` : ""}</td>
			</tr>
			`)}
		`;
				}
				$("#gamesTable tbody").append(tableTemplate(games));
				$("#gamesTable").tablesorter({
					widgets: ["filter"],
					widgetOptions: {
					}
				});
			});
	});
</script>
{% endraw %}